## 삽입정렬(Insertion Sort)
요소만큼 반복하면서 전체 카드가 정렬된다.

#### 선택 정렬과 유사하게 정렬이 된 부분과 안된 부분을 나눠진다.

i는 1이고 j는 i-1을 초깃값을 가진다.

key는 정렬되지 않은 부분을 가리키며, i의 값을 초깃값으로 가진다.

**j의 값은** key와 비교하며 **key보다 클 경우에는 j+1에 j의 값을 넣고 j를 1 뺀다.**

이때 key의 인덱스 자리에 j를 넣는다고 해도, 자리에 **원래 있던 인덱스의 값은 key에 저장되어 있어 사라지지 않는다.**

이렇게 j를 뺀 뒤 다시 위의 for문을 돌리며 선택 정렬은 앞으로 비교를 하지만 **삽입 정렬은 뒤로 비교를 한다.**

그리고 더 이상 **key보다 큰 값이 없다면 아래에는 key보다 작은 값만 있다는 것**이기에 같은 값이 2개있는 인덱스 자리인 **j+1에 key값을 넣는다.**
```c
void insertion_sort(int list[], int n) {
    int i, j, key;
    for (i = 1; i < n; i++) { 
        key = list[i];
        for (j = i-1; j >= 0 && list[j] > key; j--) {
            list[j + 1] = list[j];
        }
        list[j + 1] = key;
    }
}
```
**단순히 구현**할 수 있어, 작은 크기의 자료에는 실용적이지만, **크기가 큰 자료일 경우 비효율적**이다. 또한 수행 시간(시간 복잡도)가 **O(n²)** 느린 수행 속도를 가지고 있다.