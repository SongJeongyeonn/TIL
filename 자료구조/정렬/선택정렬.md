## 선택 정렬(Selection Sort)
두 개의 리스트가 있다고 가정하여, **왼쪽 리스트는 정렬된 것이고 오른쪽의 리스트는 정렬되지 않은 것이다.**

오른쪽 리스트에서 **가장 작은 값을 왼쪽으로 보내고, 오른쪽이 비어있으면 정렬은 끝난다.**

least는 정렬되지 않은 요소들 중에서 **가장 작은 숫자**이다.

j는 항상 i+1이며 **least와 비교되는 값**이다.

least는 초깃값을 i로 하며, j와 비교하며 마지막엔 가장 작은 값을 저장하게 된다.

least에 가장 작은 값이 저장되면 수합 매크로를 사용하여 i와 least를 교환해서 작은 값을 왼쪽으로 쌓이게 한다.

그리고 n이 배열을 크기라 하였을 때 **n-2까지만 변화한다.** 왜냐하면 **마지막에 남은 값이 가장 큰 값**이기 때문이다.
```c
void selection_sort(int list[], int n) {
    int i, j, least, temp; 
    for (i = 0; i < n; i++) {
        least = i; // i의 값을 저장해 j와 비교한다.
        for (j = i+1; j < n; j++) {
            if (list[least] > list[j]) {
                least = j; // 본인보다 작은 값을 발견하면 저장
            }
        }
        SWAP(list[i], list[least], temp); // 제일 작은 값을 왼쪽에 있는 인덱스인 i와 담긴 값을 교환한다.
    }
}
```
**단순히 구현**할 수 있어, 작은 크기의 자료에는 실용적이지만, **크기가 큰 자료일 경우 비효율적**이다. 또한 수행 시간(시간 복잡도)가 **O(n²)** 느린 수행 속도를 가지고 있다.