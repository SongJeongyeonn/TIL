# 예외(Exception)
기능이 많아질 수록 오류가 발생할 확률은 증가하기에, 정상적인 처리를 벗어난 경우를 처리하기 위한 방법이다.
```
class Calculator{
    int left, right;
    public void setOprands(int left, int right){
        this.left = left;
        this.right = right;
    }
    public void divide(){
        try {
            System.out.print("계산결과는 ");
            System.out.print(this.left/this.right);
            System.out.print(" 입니다.");
        } catch(Exception e){
            System.out.println("오류가 발생했습니다 : "+e.getMessage());
        }
    }
}
public class CalculatorDemo {
    public static void main(String[] args) {
        Calculator c1 = new Calculator();
        c1.setOprands(10, 0);
        c1.divide();

        Calculator c2 = new Calculator();
        c2.setOprands(10, 5);
        c2.divide();
    }
}
```
위의 코드에서는 0으로 나누었을 때 나오는 오류를 예방하기 위하여 try...catch문을 사용하였다.

## try...catch
```java
try{
    예외의 발생이 예상되는 로직
} catch(예외클래스 인스턴스){
    예외가 발생했을때 실행되는 로직
}
```
**try**는 예외의 발생이 예상되는 로직이 위치한다.

위의 코드에서는 setOprands의 두 번째 인자로 0이 주워졌을 때 문제가 발생할 수 있음을 예상할 수 있다.

**catch**는 try에서 예외가 발생했을 때 뒷수습을 하기 위한 로직이 위치한다.

오류가 발생하면서 try 내의 실행이 중단되고 catch 구문 안의 내용이 실행된다.

### 예외 클래스와 인스턴스 

**e는 변수**이다. 변수 앞의 **Exception은 데이터 타입**이다.

Exception은 자바에서 기본적으로 제공하는 클래스로 java.lang에 소속되어 있다. 예외가 발생하면 자바는 메소드를 호출하듯 catch를 호출하여 그 인자로 Exception 클래스의 인스턴스를 전달한다.

e.getMessage()는 자바가 전달한 인스턴스의 메소드 중 getMessage를 호출하는 코드로 **getMessage는 오류를 반환**한다.

코드의 실행결과에서 첫 줄은 '계산결과는 오류가 발생했습니다 : / by zero'이다.

이는 System.out.print(this.left/this.right); 코드에서 오류가 발생하여서

 catch문으로 넘어가 '오류가 발생했습니다 : / by zero'문장이 출력되었기 때문이다.

그리고 두번째 실행은 오류가 없으므로 '계산결과는 2 입니다.' 이렇게 계산결과가 출력된다.

## 뒷수습
```java
catch(Exception e){
            System.out.println("\n\ne.getMessage()\n"+e.getMessage());
            System.out.println("\n\ne.toString()\n"+e.toString());
            System.out.println("\n\ne.printStackTrace()");
            e.printStackTrace();
        }
```
위의 코드는 전의 catch 부분을 수정한 것이다.

#### e.getMessage();
오류에 대한 기본적인 내용을 출력해준다. 상세하지 않다.

#### e.toString()
e.toString()을 호출한 결과는 java.lang.ArithmeticException: / by zero 이다. e.toString()은 e.getMessage()보다 더 자세한 예외 정보를 제공한다. java.lang.

ArithmeticException은 발생한 예외가 어떤 예외에 해당하는지에 대한 정보라고 지금을 생각하자. ArithmeticException 수학적인 계산의 과정에서 발생하는 예외상황을 의미한다.

#### e.printStackTrace()
메소드 getMessage, toString과는 다르게 printStackTrace는 리턴값이 없다. 이 메소드를 호출하면 메소드가 내부적으로 예외 결과를 화면에 출력한다.

printStackTrace는 가장 자세한 예외 정보를 제공한다.
## 다양한 예외들
### ArrayIndexOutOfBoundsException
```java
class A{
    private int[] arr = new int[3];
    A(){
        arr[0]=0;
        arr[1]=10;
        arr[2]=20;
    }
    public void z(int first, int second){
        System.out.println(arr[first] / arr[second]);
    }
}
 
public class ExceptionDemo1 {
    public static void main(String[] args) {
        A a = new A();
        a.z(10, 1);
    }
}
```
배열 arr이는 크기가 3이지만, a.z(10,1)이라는 코드에서는 a의 10번째 인덱스를 호출하고 있다.

따라서 존재하지 않는 값을 가져오려고 하였기에 ArrayIndexOutOfBoundsException가 발생했다.

```
class A{
    private int[] arr = new int[3];
    A(){
        arr[0]=0;
        arr[1]=10;
        arr[2]=20;
    }
    public void z(int first, int second){
        System.out.println(arr[first] / arr[second]);
    }
}
 
public class ExceptionDemo1 {
    public static void main(String[] args) {
        A a = new A();
        a.z(1, 0);
    }
}
```