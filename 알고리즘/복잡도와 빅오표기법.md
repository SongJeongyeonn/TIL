## 복잡도란?
#### 복잡도는 알고리즘의 좋고 나쁨을 표현하는 지표이다.

만든 알고리즘을 실제로 컴퓨터로 구현하지 않아도 **대략적인 시간을 미리 파악**할 수 있으며, **어떤 알고리즘을 사용할지 검토**할 때도 비교하기 편리하다.

### 계산 복잡도(computational complexity)

[알고리즘](https://github.com/SongJeongyeonn/TIL/blob/main/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.md)의 예제 문제인 나이 맞히기 게임을 통해 알고리즘에 따라 계산 시간 차이가 얼마나 나는지 확인해 보자!

나이 맞히기 게임에섲는 **2가지 방법**으로 풀어보았다.

첫번째 방법은 "20살 입니까? 21살입니까? 22살입니까? .." 이렇게 순서대로 물어보는 것이었다.

질문은 나이를 맞힐 때 까지 반복한다. 이러한 방법을 **선형 탐색법(linear search)** 라고 한다.

두번째 방법은 범위의 중간을 나눠서 어느쪽인지 찾아가는 방법이었다.

이러한 방법은 **이진 탐색법(binary search)** 라고 한다.

선형 탐색법은 최대 16번 질문해야 하지만, 이진 탐색법은 4번만 물어보면 무조건 나이를 맞힐 수 있다.

만약 나이 맞히기 게임의 범위를 더 넓혀서 0세 이상 65,536세 미만이라 하면, A씨의 나이 후보는 65,536개나 된다.

이 경우 선형 탐색법과 이진 탐색법으로 A씨 나이를 맞히는데 필요한 질문 횟수는 아래와 같다.
- 선형 탐색법: 65,536번(최악의 경우)
- 이진 탐색법: 16번

이렇게 큰 차이가 발생하게 된다.

실제로 나이 맞히기 게임에서 이렇게 많은 숫자를 다룰 일은 없겠지만, 매일 수많은 데이터를 수집하는 현대 사회에서는 때때로 거대한 규모의 문제를 만날 수 있다.

그렇기에 다양한 문제를 다룰 때 **데이터의 크기가 커질수록 그에 따른 계산 시간에 영향이 적은 알고리즘**을 설계해야 한다.

여기서 설명하는 **복잡도는 실제로 알고리즘을 구현하지 않아도 계산 시간이 얼마나 걸릴지 어림짐작할 수 있는 척도의 역할**을 한다.

## 복잡도와 빅오 표기법

앞서 데이터의 크기가 증가함에 따라 알고리즘의 계산 시간이 얼마나 늘어나는지 파악하는 것이 중요하다고 하였다.

아래 단일,이중 for문의 간단한 예시를 들어서 더 깊이 알아보자.


코드 2-1
```java
// 코드 2-1 (단일 for문)
public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    int N = scanner.nextInt();
    int count = 0;
    for (int i = 0; i < N; ++i) {
        ++count;
    }
}
```

코드 2-2
```java
// 코드 2-2 (이중 for문)
public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    int N = scanner.nextInt();
    int count = 0;
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j){
            ++count;
        }
    }
}
```
위의 2-1, 2-2 코드를 xcode를 사용해 입력 값에 따라 N 값을 다양하게 바꿔가며 for 반복문 처리에 걸리는 시간을 측정하면 아래와 같은 결과가 나온다.

⬇️ 표 2-1 N 값 증가에 따른 계산 시간 변화(단위: 초)
| N            | 코드2-1   | 코드2-2  |
|--------------|----------:|----------:|
| 1,000        | 0.0000031 | 0.0029   |
| 10,000       | 0.000030  | 0.30     |
| 100,000      | 0.00034   | 28       |
| 1,000,000    | 0.0034    | 2900     |
| 10,000,000   | 0.030     | > 3600   |
| 100,000,000  | 0.29      | > 3600   |
| 1,000,000,000| 2.9       | > 3600   |

그래서 단일 for문의 복잡도는 O(N)이고 이중 for문의 복잡도는 O(N²)이다.

이는 란다우 O 표기법 또는 간단히 빅오 표기법이라 한다.

### 복잡도와 O 표기법
알고리즙 A의 계산 시간 T(N)이 대략 P(N)에 비례하면 T(N) = O(P(N))이라 표현하고, 알고리즘 A의 복잡도는 O(P(N))이라 부릅니다.

### 복잡도를 빅오 표기법으로 표기하는 이유
정수배나 낮은 차수의 항의 영향을 받지 않는 O 표기법으로 복잡도를 나타내면, 앞에서 설명한 사용 환경에 따른 미묘한 문제도 해소하고 실제로 알고리즘 계산 시간을 평가하기에 좋은 척도가 됩니다.

